#!/usr/bin/python3 -u

# 2022 eCTF
# Memory Readback Tool
# Kyle Scaplen
#
# (c) 2022 The MITRE Corporation
#
# This source file is part of an example system for MITRE's 2022 Embedded System
# CTF (eCTF). This code is being provided only for educational purposes for the
# 2022 MITRE eCTF competition, and may not meet MITRE standards for quality.
# Use this code at your own risk!

import argparse
import logging
import socket
from pathlib import Path

from cryptography.hazmat.primitives.ciphers import algorithms, modes, Cipher
from cryptography.hazmat.backends import default_backend

from util import print_banner, LOG_FORMAT, integrity_challenge, verify

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)


def readback(socket_number, region, num_bytes):
    # Print Banner
    print_banner("SAFFIRe Memory Readback Tool")

    # Connect to the bootoader
    log.info("Connecting socket...")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect(("saffire-net", socket_number))

        integrity_challenge(sock)

        # Send readback command
        log.info("Sending readback command...")
        sock.send(b"R")

        # Receive bootloader acknowledgement
        log.info("Waiting for bootloader to enter readback mode...")
        while sock.recv(1) != b"R":
            pass

        # Send the region identifier
        log.info("Sending the region identifier to read back...")
        if region == "firmware":
            # send firmware identifier
            sock.send(b"F")
            # get acknowledgement
            log.info("Waiting for bootloader to confirm the region...")
            while sock.recv(1) != b"F":
                pass
        elif region == "configuration":
            # send configuration identifier
            sock.send(b"C")
            # get acknowledgement
            log.info("Waiting for bootloader to confirm the region...")
            while sock.recv(1) != b"C":
                pass
        else:
            # send character other than an identifier to exit readback
            sock.send(b"Q")
            return

        # We don't send the number of bytes to read, we read the whole section and verify it / decrypt on our side
        # Read out size + signature + IV
        bytes_remaining = 4 + 64 + 16
        num_bytes_and_sig_and_iv = b""
        while bytes_remaining > 0:
            data = sock.recv(num_bytes)
            num_received = len(data)
            num_bytes_and_sig_and_iv += data
            bytes_remaining -= num_received

        num_bytes_read = int.from_bytes(num_bytes_and_sig_and_iv[:4], byteorder="little")
        signature = num_bytes_and_sig_and_iv[4:68]
        iv = num_bytes_and_sig_and_iv[72:]
        # Notify ready for firmware data
        sock.send(b"R")
        # Receive firmware data
        log.info("Receiving firmware...")
        bytes_remaining = num_bytes_read
        fw = b""
        while bytes_remaining > 0:
            num_bytes_read = 4096 if bytes_remaining > 4096 else bytes_remaining
            data = sock.recv(num_bytes_read)
            num_received = len(data)
            fw += data
            bytes_remaining -= num_received

        if region == "firmware":
            key_file = Path("/secrets/encryption_key.bin")
            key = key_file.read_bytes()[:32]
            cipher = Cipher(algorithms.AES(key), modes.CBC(iv), default_backend())
            decryptor = cipher.decryptor()
            fw = decryptor.update(fw) + decryptor.finalize()

        if not verify(fw, signature):
            log.error("Failed to verify signature of readback data!");
            exit(-1)

        log.info("Readback data verified OK.")

        print(f"Memory Readback Data: {fw[:num_bytes].hex()}\n")


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--socket",
        help="Port number of the socket to connect the host to the bootloader.",
        type=int,
        required=True,
    )
    parser.add_argument(
        "--region",
        help="The region to read.",
        choices=["firmware", "configuration"],
        required=True,
    )
    parser.add_argument(
        "--num-bytes",
        help="The number of bytes to read from the region.",
        type=int,
        required=True,
    )

    args = parser.parse_args()

    readback(args.socket, args.region, args.num_bytes)


if __name__ == "__main__":
    main()
